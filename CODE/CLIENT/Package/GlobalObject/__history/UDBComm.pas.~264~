unit UDBComm;

interface

uses
  System.SysUtils,UClientModule, DB, Datasnap.DBClient,RTTI, TypInfo,Types;

type
  //数据库表
  Table = class(TCustomAttribute)
  private
    FName: string;
    FTitle: string;
  published
  public
    constructor Create(ATableName, ATitle: string);
    property Name: string read FName write FName;
    property Title: string read FTitle write FTitle;
  end;
  //字段
  FieldInfo = class(TCustomAttribute)
  private
    FFieldName: string;
    FTitle: string;
  published

  public
    constructor Create(AFieldName, ATitle: string);
    //字段名
    property FieldName: string read FFieldName write FFieldName;
    //标题
    property Title: string read FTitle write FTitle;
  end;
  TStorable = class(TObject)
  public
  //插入SQL语句
  function Insert: string;
  function Select: string;
  //获取字段标题
  function GetFieldTitle(const AFieldName: string): string;
  //设置
  //function SetAttributeValue(const PropName, AttributeValue: string): Boolean;
  end;
  //数据库访问类
  TDataBaseCommObject = class(TObject)
  private
    FHostName: string;
    FPort: Integer;
    function GetConnected: Boolean;
    procedure SetConnected(const Value: Boolean);
  public
    constructor Create;
    destructor Destroy; override;
    function CheckConnected:Boolean;
    function ChangeDataBase(const ADataBaseName: string): Boolean;
    function OpenSQL(const ASQL: string; ADataSet:TClientDataSet):Integer; overload;
    function OpenSQL(const ASQL: string; const Args: array of const; ADataSet:TClientDataSet):Integer; overload;
    function ExecSQL(const ASQL: string): Integer;overload;
    function ExecSQL(const ASQL: string; const Args: array of const): Integer;overload;
    function OpenProc(szProcedureName: string; AParamName: array of string;AParamValue: array of OleVariant; ADataSet:TClientDataSet; AParams: TParams): Integer;overload;
    function OpenProc(szProcedureName: string; AParamName: array of string;AParamValue: array of OleVariant; ADataSet:TClientDataSet): Integer;overload;
    function OpenProc(szProcedureName: string; ADataSet:TClientDataSet): Integer;overload;
    function ExecProc(szProcedureName: string; AParamName: array of string;AParamValue: array of OleVariant; AParams: TParams): Integer;overload;
    function ExecProc(szProcedureName: string; AParams: TParams): Integer;overload;
    function ExecProc(szProcedureName: string): Integer;overload;
    function QueryOneFiled(const ASQL: string):Variant;
  public
    property HostName:string read FHostName write FHostName;
    property Port:Integer read FPort write FPort;
    property Connected:Boolean read GetConnected write SetConnected;
  end;

implementation

uses
  System.Variants;

{ TDataBaseCommObject }

function TDataBaseCommObject.ChangeDataBase(const ADataBaseName: string): Boolean;
begin
  Result := False;
  if not CheckConnected then Exit;
  Result := ClientDM.ChangeDataBase(ADataBaseName);
end;

function TDataBaseCommObject.CheckConnected: Boolean;
begin
  if not Result then Connected := True;
  Result := Connected;
end;

constructor TDataBaseCommObject.Create;
begin
  ClientDM := TClientModule.Create(nil);
end;

destructor TDataBaseCommObject.Destroy;
begin
  if Assigned(ClientDM) then FreeAndNil(ClientDM);
  inherited;
end;

function TDataBaseCommObject.ExecProc(szProcedureName: string;AParamName: array of string; AParamValue: array of OleVariant; AParams: TParams): Integer;
begin
  Result := -1;
  if not CheckConnected then Exit;
  Result := ClientDM.ExecProc(szProcedureName,AParamName,AParamValue,AParams);
end;

function TDataBaseCommObject.ExecProc(szProcedureName: string): Integer;
var AParams: TParams;
begin
  AParams := TParams.Create(nil);
  try
    Result := ExecProc(szProcedureName,AParams);
  finally
    AParams.Free;
  end;
end;

function TDataBaseCommObject.ExecProc(szProcedureName: string; AParams: TParams): Integer;
begin
  Result := ExecProc(szProcedureName,[],[],AParams);
end;

function TDataBaseCommObject.ExecSQL(const ASQL: string; const Args: array of const): Integer;
begin
  Result := ExecSQL(Format(ASQL,Args));
end;

function TDataBaseCommObject.ExecSQL(const ASQL: string): Integer;
begin
  Result := -1;
  if not CheckConnected then Exit;
  Result := ClientDM.ExecSQL(ASQL);
end;

function TDataBaseCommObject.GetConnected: Boolean;
begin
  Result := ClientDM.conn.Connected;
end;

function TDataBaseCommObject.OpenProc(szProcedureName: string; AParamName: array of string; AParamValue: array of OleVariant; ADataSet: TClientDataSet; AParams: TParams): Integer;
begin
  Result := -1;
  if not CheckConnected then Exit;
  Result := ClientDM.OpenProc(szProcedureName,AParamName,AParamValue,ADataSet,AParams);
end;

function TDataBaseCommObject.OpenProc(szProcedureName: string; AParamName: array of string; AParamValue: array of OleVariant; ADataSet: TClientDataSet): Integer;
begin
  Result := OpenProc(szProcedureName,AParamName,AParamValue,ADataSet);
end;

function TDataBaseCommObject.OpenProc(szProcedureName: string; ADataSet: TClientDataSet): Integer;
begin
  Result := OpenProc(szProcedureName,[],[],ADataSet);
end;

function TDataBaseCommObject.OpenSQL(const ASQL: string; const Args: array of const; ADataSet: TClientDataSet): Integer;
begin
  Result := OpenSQL(ASQL,Args,ADataSet)
end;

function TDataBaseCommObject.OpenSQL(const ASQL: string; ADataSet: TClientDataSet): Integer;
begin
  Result := -1;
  if not CheckConnected then Exit;
  Result := ClientDM.OpenSQL(ASQL,ADataSet);
end;

function TDataBaseCommObject.QueryOneFiled(const ASQL: string): Variant;
begin
  Result := Null;
  if not CheckConnected then Exit;
  Result := ClientDM.QueryOneFiled(ASQL);
end;

procedure TDataBaseCommObject.SetConnected(const Value: Boolean);
begin
  if ClientDM.conn.Connected = Value then Exit;
  try
    ClientDM.Conn.Connected := False;
    ClientDM.Conn.Params.Values['HostName'] := HostName;
    ClientDM.Conn.Params.Values['Port']     := Port.ToString;
    ClientDM.Conn.Connected := Value;
  except on E: Exception do
  end;
end;

{ Table }

constructor Table.Create(ATableName, ATitle: string);
begin
  FName  := ATableName;
  FTitle := ATitle;
end;

{ FieldInfo }

constructor FieldInfo.Create(AFieldName, ATitle: string);
begin
  FFieldName := AFieldName;
  FTitle     := ATitle;
end;

{ TStorable }

function TStorable.GetFieldTitle(const AFieldName: string): string;
var
  Context: TRttiContext;
  typ: TRttiType;
  A2: TCustomAttribute;
  Prop: TRttiProperty;
begin
  Context := TRttiContext.Create;
  try
    typ := Context.GetType(ClassType);
    for Prop in typ.GetProperties do
    begin
      for A2 in Prop.GetAttributes do
      begin
        if (A2 is FieldInfo) and SameText(FieldInfo(A2).FieldName, AFieldName) then
        begin
          Result := FieldInfo(A2).Title;
          Break;
        end;
      end;
    end;
  finally
    Context.Free;
  end;
end;

function TStorable.Insert: string;
var
  Context:TRttiContext;
  Prop:TRttiProperty;
  typ:TRttiType;
  A1,A2:TCustomAttribute;
  Sqls,Fields,Values,Value:string;
begin
  Context := TRttiContext.Create;
  try
    Sqls := '';
    Fields := '';
    Values := '';
    typ := Context.GetType(ClassType);
    for A1 in typ.GetAttributes do
    begin
      if A1 is Table then
      begin
        Sqls := 'Insert Into '+Table(A1).Name; //获取Insert表名
        for Prop in typ.GetProperties do
        begin
          for A2 in Prop.GetAttributes do
          begin
            if A2 is FieldInfo then //AHa
            begin
              Fields := Fields + ','+ FieldInfo(A2).FieldName ;
              // the value of the attribute
              Value := Prop.GetValue(Self).ToString;
              //根据数据类型对属性值加以编辑
              case Prop.GetValue(Self).Kind of
                tkString, tkChar, tkWChar, tkWString, tkUString: Value := QuotedStr(Value);
                tkInteger, tkInt64, tkFloat: Value := Value;
              else
                Value := QuotedStr(Value);
              end;
              Values := Values + ',' + Value ;
            end; //for A2 in Prop.GetAttributes
          end;
        end; //enf of for Prop
        Delete(Fields,1,1);
        Delete(Values,1,1);

        Sqls := Sqls + ' (' + Fields + ') VALUES (' + Values + ');';
        Result := Sqls;
      end; //if A1 is Table then
    end; //for A1 in typ.GetAttributes do
  finally
    Context.Free;
  end;
end;

function TStorable.Select: string;
var
  Context:TRttiContext;
  Prop:TRttiProperty;
  typ:TRttiType;
  A1,A2:TCustomAttribute;
  Sqls,Fields,Values,Value:string;
begin
  Context := TRttiContext.Create;
  try
    Sqls := '';
    Fields := '';
    Values := '';
    typ := Context.GetType(ClassType);
    for A1 in typ.GetAttributes do
    begin
      if A1 is Table then
      begin
        Sqls := 'Insert Into '+Table(A1).Name; //获取Insert表名
        for Prop in typ.GetProperties do
        begin
          for A2 in Prop.GetAttributes do
          begin
            if A2 is FieldInfo then //AHa
            begin
              Fields := Fields + ','+ FieldInfo(A2).FieldName ;
            end; //for A2 in Prop.GetAttributes
          end;
        end; //enf of for Prop
        Delete(Fields,1,1);
        Sqls := Sqls + ' (' + Fields + ') VALUES (' + Values + ');';
        Result := Format('select %s from %s',[Fields,Table(A1).Name]);
      end; //if A1 is Table then
    end; //for A1 in typ.GetAttributes do
  finally
    Context.Free;
  end;
end;

end.
